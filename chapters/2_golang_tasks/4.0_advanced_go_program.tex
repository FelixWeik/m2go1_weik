\subsection{Excercise GettingStartedWithCarRentalCLI}
\label{sec:exercise_getting_started_with_car_rental_cli}
This task aims to get familiar with the given code and to understand the structure of the application.

First, the CLI parameters are analyzed and complete \autoref{tab:cli_parameters_car_rental_cli}.
After that, we'll deepdive into the architecture by describing and analyzing software and micro architecture.
The last step is to start the program and to rent a car for Max.

These tasks will provide a fundamental understanding of the application and its structure.

\subsubsection*{Analyze the CLI Parameters}
Goal of this task is to derive input and output parameters for the CLI commands.
\autoref{tab:cli_parameters_car_rental_cli} is based on the given task sheet and contains the input and output parameters for the CLI commands.

Empty fields are the command for registering as a customer, the input for canceling a rental, and command, input, and output for deregistering as a customer.

The command for registering as a customer is \texttt{register} since it clearly describes the intention and action of the command.

Input for cancelling a rental is the rentalID and the customerID.
Both values are needed to clearly identify the rental and authenticate the customer.
If both values are correct, the rental can be cancelled.

The command for deregistering as a customer is \texttt{deregister} since it clearly describes the intention and action of the command.
Only the customerID is needed as input, since it identifies the customer and the customer can only deregister himself.
If the deregistration is successful, the customerID is returned to the CLI, showing the value that will be deleted from the yaml file.
If the deregistration fails, the CLI returns a failure message.

The results of entering the values into the fields are shown in \autoref{tab:cli_parameters_car_rental_cli}.
The inserted values are underlined.

\begin{table}
      \centering
      \caption{CLI Parameters for CarRentalCLI}
      \label{tab:cli_parameters_car_rental_cli}
      \begin{tabular}{|p{4cm}|p{2cm}|p{4cm}|p{5cm}|}
            \hline
            \multicolumn{4}{|c|}{\textbf{CLI Parameters for CarRentalCLI}} \\
            \hline
            \textbf{Use Case} & \textbf{Command} & \textbf{Input} & \textbf{Output} \\
            \hline
            Register as Customer & \underline{register} & CustomerID, Name & CustomerID / Failure \\
            \hline
            Rent a Car & rent & RentalID, CustomerID, CarID, StartDate, EndDate & RentalID / Failure \\
            \hline
            Cancel Rental & cancel & \underline{RentalID, CustomerID} & RentalID / Failure \\
            \hline
            Deregister as Customer & \underline{deregister} & \underline{CustomerID} & \underline{CustomerID / Failure} \\
            \hline
      \end{tabular}
\end{table}

\subsubsection*{Describe the Software Architecture}
The given task starts with three different software components:
\begin{itemize}
    \item Presentation Layer: CarRentalCLI
    \item Application Logic Layer: CarRentalOperations
    \item Infrastructure Layer: CarRentalRepository
\end{itemize}
\subsubsection*{Presentation Layer: CarRentalCLI}
\begin{itemize}
    \item Functionality: This component implements the CLI itself. 
          It creates a new CLI object, runs it, and exits safely if an error occurs.
          Furthermore, it implements the CLI commands with the list of according functions a command calls.
    \item Interfaces: The CLI component implements the CarRentalOperationsInterface
    \item Dependencies: This layer is dependent from the applications logic layer, importing and implementing functions from the logic layer.
    \item Reusability: The layer is reusable since it only implements CLI and commands.
          By providing a different set of function the CLI implements, one can reuse the CLI in a different context.
    \item Scalability and Maintainability: It can be scaled by adding new commands and functions to the CLI.
          It can be maintained by fixing commands and the according functions.
          By separating the CLI into a single layer, the commands can be organized systematically and provide great overview.
\end{itemize}

\subsubsection*{Application Logic Layer: CarRentalOperations}
\begin{itemize}
    \item Functionality: This component implements the business logic of the application.
          It provides functions for the CLI to call, which then call the according functions from the infrastructure layer.
          It also provides the models of the objects, that are used in the application.
    \item Interfaces: This component implements the CarRentalRepositoryInterface and provides the CarRentalOperationsInterface
    \item Dependencies: This component is dependent from the infrastructure layer and therefore dependent from the layer below.
    \item Reusability: Since this component uses the infrastructure layer, it is not directly reusable.
          It implements a specific set of functions, which cannot be reused in different contexts.
    \item Scalability and Maintainability: It can be scaled by adding new functions to the component.
          It can be maintained by fixing functions.
\end{itemize}

\subsubsection*{Infrastructure Layer: CarRentalRepository}
\begin{itemize}
    \item Functionality: This component implements yaml mappers and entities. 
          This allows for simple communication between the application and the yaml files.
          The yaml mappers provide functions to read and write yaml files.
          The entities provide the structure of the yaml files and the structure of the struct the mapper creates.
    \item Interfaces: This component provides the CarRentalRepositoryInterface
    \item Dependencies: The component is dependent from the provided yaml files, since it reads and writes them.
          In terms of functionality, no functionality imports from other parts of the application are needed since all functions are implemented in the component itself.
    \item Reusability: This component is reusable since it only implements yaml mappers and entities.
          By providing a different set of entities and mappers, one can reuse the component in a different context.
    \item Scalability and Maintainability: By adding new mappers and entities, the functionality can be extended.
          By fixing the mappers and entities, the maintainability can be ensured.
\end{itemize}

\subsubsection*{Analyze the Micro Architecture}
%// TODO Micro Architecture beschreiben / erkl√§ren
The micro architecture of an application describes the internal structure of a single subsystem.


\subsubsection*{Start the Go Program CarRentalCLI}
The output after starting the program successfully is displayed in \autoref{fig:car_rental_cli_successful_rental_max}.
The program asks for the id of the customer and the id of the car.
After entering the ids, the program asks for the start and enddate of the rental by asking for the day, month and year.
If the data is entered correctly and the rental is successful, the program prints a success message and exits.
Otherwise, the program asks for the remaining data, prints an error message, the exit-status and exits.

\begin{figure}
      \centering
      \includegraphics[width=0.8\textwidth]{figures/goLang/carRental/carRentalCLI/carRentalCli_SuccessfulRentalMax.png}
      \caption{Successful Rental of a Car for Max}
      \label{fig:car_rental_cli_successful_rental_max}
\end{figure}

\subsection{Excercise AddRegisterAsCustomer}
\label{sec:exercise_add_register_as_customer}
This task aims to add the functionality to register as a customer.

To fulfill this task, the following steps are required:
First, a CLI command is added to the presentation layer which calls the basic functions to register a new customer.
After that, an entity mapper is added to the infrastructure layer.
Then, the operation is implemented including validations.
The last step is to test the functionality by registering Alice as a customer.

This is a hands on task, which requires to add code to the existing application.

\subsubsection*{Add CLI Command}
The CLI commands are placed in the \texttt{CarRentalCLI.go} file.
The \texttt{NewCarRentalCLI} function takes \texttt{operations.CarRentalOperations} as input and returns a \texttt{CarRentalCLI} object that can later be executed.
This function also specifies the commands that can be executed by the CLI.
The array \texttt{Commands} contains these commands consisting out of the name, the usage, and the according action.

To add the command for registering a new customer, the array \texttt{Commands} is extended by the command \texttt{register} with the usage \texttt{Register as Customer}.
The action defines a function taking a CLI-context object as input and returning an error.
This function calls the according function that executes the code executing the actual task.

The code for the new CLI command \texttt{register} is shown in \autoref{lst:car_rental_cli_command_register}.

\begin{lstlisting}[
      style=kit-cm,
      caption={Code for the CLI Command "register"},
      label={lst:car_rental_cli_command_register},
      language=Golang
]
...
// array and function definition
... // other commands
{
      Name:  "register",
      Usage: "Register as Customer",
      Action: func(cCtx *cli.Context) error {
            return RegisterAsCustomerAction(operations)
      },
},
... // other commands
\end{lstlisting}

\subsubsection*{Add Entity Mapper}
So, why is a mapper required?
The general task of a mapper is to enable communication between the application and the database.
In this case, the database is a yaml file.
Therefore the mapper can read and write to the yaml files and convert the data to the according entities and vice versa.

In the use case of registering a new customer, the mapper is called while creating a new customer.
This mapper is located in the \texttt{./CustomerMapper.go} file, containing two functions.
The first function \texttt{ConvertCustomerToCustomerPersistenceEntity} takes a customer object as argument and returns a customer persistence entity containing the same values.
This entity is then written to the yaml file.
By writing the entity into the yaml file, the customer is registered and can be used in the application.

The second function \texttt{ConvertCustomerPersistenceEntityToCustomer} takes a customer persistence entity as argument and returns a customer object containing the same values.
It acts just like the function above, but in the opposite direction.

This task is about implementing the \texttt{ConvertCustomerToCustomerPersistenceEntity} function.
The code for this function is shown in \autoref{lst:car_rental_cli_mapper_customer_to_customer_persistence_entity}.

\begin{lstlisting}[
      style=kit-cm,
      language=Golang,
      caption={Code for the ConvertCustomerToCustomerPersistenceEntity Function},
      label={lst:car_rental_cli_mapper_customer_to_customer_persistence_entity},
]
// CustomerMapper.go
// author = Felix Weik

func ConvertCustomerToCustomerPersistenceEntity(customer model.Customer) entities.CustomerPersistenceEntity {
return entities.CustomerPersistenceEntity{
      ID:   customer.ID,
      Name: customer.Name,
}
}
\end{lstlisting}

\subsubsection*{Implement Operation}
The registering process is implemented in separate files across the different layers.

The CLI command "register" calls the \texttt{RegisterAsCustomerAction} function starting from the \texttt{CarRentalCLI.go} file.
This function is located in the \texttt{CliActions.go} file.
It prints a message to the CLI and collects the customerID and the customerName attributes via other functions from the CLI package.

After that, it calls the \texttt{RegisterAsCustomer} function that takes both collected \hfill \linebreak values as input.
This function is located in the operations package in the \hfill \linebreak \texttt{RegisterAsCustomerOperation.go} file.
It validates the input by checking if the customer exists.
If the input is valid, it calls the \texttt{NewCustomer} and \texttt{CreateCustomer} functions, which are located in the models package.
These functions will write to the yaml file, storing the new customer.

If an error occurs or the validations fail, the process will abort.
If the process succeeds, a success message containing the newly created customerID is printed to the CLI.

\subsubsection*{Register Alice as Customer}
After running the CLI command to register a new customer, the program asks for the ID of the customer.
In this case Alice receives the ID \texttt{Cus5}.
After entering the ID, the program asks for the name of the customer, in this case Alice.
The program exits with a success message and the exit-status as shown in \autoref{fig:car_rental_cli_register_alice}.

To register a new rental, the programm starts with \texttt{go run . -- rent}.
The program asks for the ID of the rental, here it is \texttt{Rental7}.
The customer ID for Alice is \texttt{Cus5}.
After that the start and enddate is entered.
The program exits with a success message and the exit-status as shown in \autoref{fig:car_rental_cli_rental_alice_successful}.

\begin{figure}
      \centering
      \includegraphics[width=0.8\textwidth]{figures/goLang/carRental/carRentalCLI/carRentalCLI_RegisterAlice.png}
      \caption{Register Alice as a Customer}
      \label{fig:car_rental_cli_register_alice}
\end{figure}
\begin{figure}
      \centering
      \includegraphics[width=0.8\textwidth]{figures/goLang/carRental/carRentalCLI/carRentalCLI_SuccessfulRentalAlice.png}
      \caption{Successful Rental of a Car for Alice}
      \label{fig:car_rental_cli_rental_alice_successful}
\end{figure}
