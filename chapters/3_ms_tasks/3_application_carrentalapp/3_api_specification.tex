\subsection{Excercise gRPCAMRentalManagementV1.0}
TODO: add an introduction

\subsubsection*{Specification Language}
% Describe which API specification language is used for gRPC
gRPC uses the protocol buffer language to define the API specification \cite{PRO-DOC}.
The protocol buffer language is platform-independent and language-agnostic.
Using this language, data structures and services can be defined.

The API specification is defined in a \texttt{.proto} file serving as the groundwork for the implementation of the client- and server-implementation.
The \texttt{.proto} file is compiled by a protobuf compiler to generate the client- and server-side code.
This code then defines the data structures and service stubs of the \texttt{.proto} file.

In the \texttt{.proto} file, messages and services can be defined.
Messages are used to define data structures.
They rank optional and required fields, specifying how the data will be serialized.
After compiling a message using the protobuf compiler, the message can be used as a class in the target language.
This class can then be used to create instances of the message, serializing and deserializing them.
The serialized data can then be used for transmission, persisting or storing.
A service defines remote procedures.
They hold one or several functions, specifying the parameters and return values of the function.
The logic of the function can be directly implemented in the service definition, or it can be implemented in a separate class.
The service can then be used to create a server stub and a client stub.
Therewith, the service can be used to implement a server and a client, enabling communication by specifying the remote procedure calls.

\subsubsection*{Constructing gRPC Services}
% Which parts of the API diagram are mapped to gRPC services and why?
% How are methods within an application entity transformed into gRPC functions according to the guideline?
The guidelines on deriving gRPC specifications are provided in the \hfill \linebreak \texttt{1.EngineeringKnowledge > 1.UMEPhases} GitLab Repository \cite{CM-G-RPC}.
It defines certain rules on how and what to derive from a given API diagram into the gRPC specification.
First, each entity or collection that houses gRPC functions is mapped to a gRPC service.
The service is named after the entity or collection with the suffix \texttt{Service} or \texttt{CollectionService}.
Also, the gRPC functions are named after the corresponding methods of the entity or collection.
Next, each enumeration is mapped to a gRPC enumeration with each value being translated to a gRPC enumeration value.
Then, each entity is mapped to a gRPC message having the same name and attributes as the entity.
Finally, each input and output parameter of the defined gRPC functions is defined as a single message.
Each message contains the attributes of the input or output parameter.
These messages are named after the corresponding method with the suffix \texttt{Request} or \texttt{Response}.
They are then used as input or output parameters of the corresponding gRPC function. \linebreak
All the other value objects and entities are mapped to gRPC messages.
This enables the implementation of the gRPC service.
Without proper implementation, the gRPC service will not be able to handle remote procedure calls or serialize and deserialize data properly.

% Describe the mapping with the application entity Customer from the API diagram AM-RentalManagementV1.0 to the corresponding methods of a gRPC service
A code snippet of \texttt{AM-RentalManagementV1.0}'s \texttt{.proto} file is shown in Listing \autoref{lst:proto_customer_service}.
The according API diagram is shown in \autoref{fig:ad_am-rental_management_v1.0}.
In the API diagram, the \texttt{Customer} application entity holds three functions and two attributes.
Therefore, the \texttt{Customer} application entity is mapped to a gRPC service named \texttt{CustomerService} holding three gRPC functions.
Here, each function is named after the corresponding method, with input and output parameters named as described above.
Each input and output parameter is defined in a single message holding the attributes of the original function.
Afterward, the \texttt{Customer} application entity is mapped to a message named \texttt{Customer} holding two attributes.
This concludes the derivation of the \texttt{Customer} application entity into the protobuf gRPC specification.

\begin{lstlisting}[
    style = kit-cm,
    caption = {Code Snippet of \texttt{AM-RentalManagementV1.0}'s \texttt{.proto} File},
    label = {lst:proto_customer_service}
]
//AM-RentalManagementV1.0
syntax = "proto3";

package rentalmanagement;

option go_package = "./pb";

import "google/protobuf/timestamp.proto";

...

service CustomerService{
    rpc RentCar(RentCarRequest) returns (RentCarResponse) {}
    rpc ListRentals(ListRentalsRequest) returns (ListRentalsResponse) {}
    rpc CancelRental(CancelRentalRequest) returns (CancelRentalResponse) {}
}

message RentCarRequest {
    google.protobuf.Timestamp startDate = 1;
    google.protobuf.Timestamp endDate = 2;
    Vin vin = 3;
    string customerId = 4;
}

message RentCarResponse {
    Rental rental = 1;
    ErrorDetail error = 2;
}

message ListRentalsRequest {
    string customerId = 1;
}

message ListRentalsResponse {
    repeated Rental rentals = 1;
    ErrorDetail error = 2;
}

message CancelRentalRequest {
    string rentalId = 1;
}

message CancelRentalResponse {
    bool result = 1;
    ErrorDetail error = 2;
}

message Customer {
    string customerId = 1;
    string name = 2;
}

...
\end{lstlisting}
\subsubsection*{Map Enumerations to gRPC Enums}
% How are enumerations in the API diagram mapped to gRPC enums
As explained above, each enumeration from the API diagram is mapped to a gRPC enum type.
Each value of the enumeration is then mapped to a gRPC enum value.
% Why is it important to set default values for gRPC enums
A default value is set at zero with the other values being incremented by one.
This is important due to the way gRPC handles enums.
If a value is not set, the default value is used.
Therefore the default value should be set carefully.

% Provide an example of mapping enumeration VehicleCategory from API diagram to gRPC enums
Assume there is an enumeration \texttt{VehicleCategory} with the values \texttt{Compact}, \texttt{Midsize}, \texttt{Fullsize} and \texttt{Luxury}.
Now a default value must be set, \texttt{UNSPECIFIED} is chosen in this example.
Therefore \texttt{UNSPECIFIED} is mapped to the value zero with the other values following.
If a \texttt{Car} is now assigned an unspecified \texttt{VehicleCategory}, it will be set to \texttt{UNSPECIFIED}.
A code example implementing the \texttt{VehicleCategory} enumeration is shown in Listing \autoref{lst:proto_vehicle_category}.

\begin{lstlisting}[
    style = kit-cm,
    caption = {Example of a \texttt{.proto} File representing the Enumeration \texttt{VehicleCategory}},
    label = {lst:proto_vehicle_category},
    float = h
]
...
enum VehicleCategory {
    UNSPECIFIED = 0;
    COMPACT = 1;
    MIDSIZED = 2;
    FULLSIZED = 3;
    LUXURY = 4;
}
...
\end{lstlisting}
\subsubsection*{Translate Entities and Value Objects to gRPC Messages}
% Identify modeling elements that will be transferred from the API diagram to gRPC messages
As mentioned above, each entity or collection is modeled as a message.
It holds only the attributes since its methods are already modeled in the according service.
Also, each input and output parameter of the services' functions are modeled as messages.
Therefore, the application entities \texttt{Customer} and \texttt{Car} as well as the \texttt{Rental} collection will be modeled as messages holding their attributes.
All of the functions' input and output parameters that these three objects hold will be modeled as messages.
For example the input and output parameters of \texttt{rentCar} in the \texttt{Customer} application entity will be modeled as two distinct messages holding the input and return parameters.

% What attributes are encompassed within the message derived from the application entity 
\autoref{lst:proto_car_service} shows a code snippet of \texttt{AM-RentalManagementV1.0}'s \texttt{.proto} file specifying the \texttt{Car} message.
In the API diagram, the \texttt{Car} application entity inherits the domain entity \texttt{Car} from the \texttt{DM-CarV1.0} domain microservice.
Therefore, the \texttt{Car} message holds the same attributes as the \texttt{Car} domain entity does.
These attributes are then specified in the \texttt{.proto} file.
Also, the datatypes of the attributes are preserved.
The \texttt{Vin} value object is also modeled as a message, serving as a datatype for \texttt{Car}'s attribute \texttt{vin}.

% Discuss strategy for managing simple and complex identifier attributes in gRPC messages for entities
An example of a simple identifier attribute is the \texttt{vin} attribute of the \texttt{Car} message.
It is modeled as a string without any further nesting.
It will be used as the unique identifier for the \texttt{Car} message.
In the mentioned guideline on deriving gRPC specifications \cite{CM-G-RPC}, more complex identifier attributes will be modeled as nested messages within the message that will be identified.
This nested message will then be used as a datatype for the identifier attribute.
An example of a more complex, nested identifier attribute is shown in Listing \autoref{lst:proto_nested_identifier}.

Several alternatives are possible:
First, the identifier attribute can be modeled as a message, yet without nesting.
This is the case for the \texttt{vin} attribute of the \texttt{Car} message.
This enables the reusability of the identifier attribute, since in \autoref{lst:proto_nested_identifier} the \texttt{Identifier} cannot be reused by other messages.
Second, one could compromise and model the identifier attribute as a simple datatype.
This would enable the reusability of the identifier attribute, yet information will be lost.
Also, the \texttt{vin} attribute for example will not be a reusable, unified datatype then.
Therefore, modeling the identifier attribute as a message without nesting is the best solution.

\begin{lstlisting}[
    style=kit-cm,
    caption={Code Snippet of \texttt{AM-RentalManagementV1.0}'s \texttt{.proto} File},
    label={lst:proto_car_service}
    float=h
]
message Car {
    Vin vin = 1;
    string brand = 2;
    string model = 3;
    int32 pricePerDay = 4;
}

message Vin {
    string vin = 1;
}
\end{lstlisting}

\begin{lstlisting}[
    style=kit-cm,
    caption={Code Snippet showing a Nested Identifier Message from \cite{CM-G-RPC}},
    label={lst:proto_nested_identifier},
    float=h
]
message Car {
    Identifier id = 1;
    // other attributes
    message Identifier {
        string vin = 1;
        string registrationNumber = 2;
    }
}
\end{lstlisting}
\subsubsection*{Transfer Parameters for gRPC Function}